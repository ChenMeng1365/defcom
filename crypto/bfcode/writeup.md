---
marp: true
---

# bfcode writeup

首先这个题存在`,`(标准输入)，不输入程序就会一致中断等待  
再就是有很阴险的`[+-]`(死循环)，可以说运行必定卡死的  
那么只能从语义入手，划分出如下39段

程序的实际含义：
前面38段都以`,`开头，要求一个输入值（按键值转化为ord）  
然后每段通过若干`+`再生成一个特定值`n`，之后`[<++++++++++>-]<`（乘以10），再若干`+`加上一个特定值`m`，再执行`[<->-]<`（即`n*10+m`减去输入值），每段得到一个结果  
可以说输入和输出相关，如果每段都输入0，那么每段程序设定的结果就是`n*10+m`
最后1段固定输出`ok`

---

```txt
154 ,>>++++++++++[<++++++++++>-]<++[<->-]<
148 ,>>++++++++++[<++++++++++>-]<++++++++[<->-]<
159 ,>>+++++++++[<++++++++++>-]<+++++++[<->-]<
153 ,>>++++++++++[<++++++++++>-]<+++[<->-]<
133 ,>>++++++++++++[<++++++++++>-]<+++[<->-]<
204 ,>>+++++[<++++++++++>-]<++[<->-]<
206 ,>>+++++[<++++++++++>-]<[<->-]<
204 ,>>+++++[<++++++++++>-]<++[<->-]<
202 ,>>+++++[<++++++++++>-]<++++[<->-]<
156 ,>>++++++++++[<++++++++++>-]<[<->-]<
205 ,>>+++++[<++++++++++>-]<+[<->-]<
159 ,>>+++++++++[<++++++++++>-]<+++++++[<->-]<
199 ,>>+++++[<++++++++++>-]<+++++++[<->-]<
207 ,>>++++[<++++++++++>-]<+++++++++[<->-]<
208 ,>>++++[<++++++++++>-]<++++++++[<->-]<
200 ,>>+++++[<++++++++++>-]<++++++[<->-]<
202 ,>>+++++[<++++++++++>-]<++++[<->-]<
204 ,>>+++++[<++++++++++>-]<++[<->-]<
157 ,>>+++++++++[<++++++++++>-]<+++++++++[<->-]<
157 ,>>+++++++++[<++++++++++>-]<+++++++++[<->-]<
158 ,>>+++++++++[<++++++++++>-]<++++++++[<->-]<
199 ,>>+++++[<++++++++++>-]<+++++++[<->-]<
207 ,>>++++[<++++++++++>-]<+++++++++[<->-]<
199 ,>>+++++[<++++++++++>-]<+++++++[<->-]<
154 ,>>++++++++++[<++++++++++>-]<++[<->-]<
157 ,>>+++++++++[<++++++++++>-]<+++++++++[<->-]<
201 ,>>+++++[<++++++++++>-]<+++++[<->-]<
208 ,>>++++[<++++++++++>-]<++++++++[<->-]<
208 ,>>++++[<++++++++++>-]<++++++++[<->-]<
154 ,>>++++++++++[<++++++++++>-]<++[<->-]<
199 ,>>+++++[<++++++++++>-]<+++++++[<->-]<
202 ,>>+++++[<++++++++++>-]<++++[<->-]<
203 ,>>+++++[<++++++++++>-]<+++[<->-]<
205 ,>>+++++[<++++++++++>-]<+[<->-]<
155 ,>>++++++++++[<++++++++++>-]<+[<->-]<
158 ,>>+++++++++[<++++++++++>-]<++++++++[<->-]<
200 ,>>+++++[<++++++++++>-]<++++++[<->-]<
131 ,>>++++++++++++[<++++++++++>-]<+++++[<->-]<
107 >>>>>+++++++++++[<++++++++++>-]<+.>>>>>++++++++++[<++++++++++>-]<+++++++.
```

---

自用调试脚本，需要能看到bf机运行状态下当前指针所指单元值  
或者手工去掉`,`，并在38段代码最后加上`.`

```ruby
$LOAD_PATH << '.'
require 'brainfuck'

begin
  scripts = DATA.read.gsub("\n","").gsub(" ","").split("[+-]")
  bfp = BrainFuck.new
  inputs = scripts.size.times.map{|i|(0).chr}
  output = []

  scripts.each_with_index do|script,idx|
  bfp.run script,'input'=> [inputs[idx]],'outpath'=>nil,'tracepath'=>nil
    output << [inputs[idx], bfp.value, script]
  end

  File.write 'output.txt',output.map{|o|o.join("\t")}.join("\n")
end
```

---

然后对output序列找规律（最后一位输出无关，只取前38个）

```ruby
  output = [154, 148, 159, 153, 133, 204, 206, 204, 202, 156, 205, 
  159, 199, 207, 208, 200, 202, 204, 157, 157, 158, 199, 207, 199, 
  154, 157, 201, 208, 208, 154, 199, 202, 203, 205, 155, 158, 200, 131, 107]
  output = output[0..-2]
  flag = 'flag{'.split('').map{|c|c.ord}
```

a-z、A-Z、0-9、{、}的值为97-122、65-90、48-57、123、125，output基本都超了范围  
假设FLAG形如`flag{xxx}`，那么比较output序列每一位和flag序列每一位差值，但找不出规律

```ruby
  def cmpbit seq1,seq2
    diffput = []
    seq1.each_with_index do|v,i|
      diffput << seq1[i] -seq2[i]
    end
    return diffput
  end

  cmpseq = cmpbit output[0..4], flag
  p cmpseq # [52, 40, 62, 50, 10] 没有规律
```

---

还有另一种比较方法，就是输出序列的某一位和前一位/后一位差值是否存在某种关系

```ruby
  def diff seq
    diffput = []
    seq.each_with_index do|v,i|
      n = i+1==seq.size ? 0 : i+1
      diffput << seq[i] - seq[n]
    end
    return diffput
  end

  diffseq = diff output
  diffres = diff flag
  p diffseq,diffres[0..-2] 
  # [6, -11, 6, 20, -71, -2, 2, 2, 46, -49, 46, -40, -8, -1, 8, -2, -2, 47, 
  #  0, -1, -41, -8, 8, 45, -3, -44, -7, 0, 54, -45, -3, -1, -2, 50, -3, -42, 69, -23]
  # [-6, 11, -6, -20]
```

可以看出，output和flag的每一位对比下一位的差值有**相同的数值**，符号相反（falg仅到`g{`）  
类似共振，output序列根据本位和下一位的差值，可以推算出flag下一位原来的数值

---

根据上述规律，从`{`开始构建flag剩余内容

```ruby
  diffseq[4..-1].each do|d|
    next_guess = flag[-1] + d#*(-1)
    flag << next_guess
  end
  p flag.map{|c|c.chr}.join[0..-2] # "flag{4246d3a910864ccb919fc700f9653eb8}"
```
