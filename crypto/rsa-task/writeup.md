
# rsa-task

有题目可知, pq是离着很近的数  
于是从n的平方根开始按顺序找附近的质数，直到能被n整除  
第一个满足的数先拿过来看看

解法一

```python
from gmpy2 import *
from Crypto.Util.number import *

n = 137815937454100380078766964983719175719508686463921553457616887444315719743431933754246120678262357002034374915224770760760736162169482725400822338474731156116786712978656738500229117842566353887040038416475721113811857644429262967915859356883870208831618273908161669865523856212035407398267169855682638005133
c = 2032888082723574429454045459717621815801322957369035978945798059432422258770805894251340680015217981155199899045627618601293804229082398619545630862829253928922147351403929796608182862360884493684335369478368770819127290582786157697798388245982826545951852875217150701541970900785626379830835719158822235848
e = 65537

p = iroot(n, 2)[0]
while True:
  if n % p == 0:
    q = n // p
    break
  p += 1
print(p, q)

d = invert(e, (p-1)*(q-1))
m = powmod(c, d, n)
flag = long_to_bytes(m)
print(flag) # flag{25adeb5c641848b8a1a6871bd0b162ae}
```

解法二

```python
from binascii import unhexlify
import gmpy2

n = 137815937454100380078766964983719175719508686463921553457616887444315719743431933754246120678262357002034374915224770760760736162169482725400822338474731156116786712978656738500229117842566353887040038416475721113811857644429262967915859356883870208831618273908161669865523856212035407398267169855682638005133
c = 2032888082723574429454045459717621815801322957369035978945798059432422258770805894251340680015217981155199899045627618601293804229082398619545630862829253928922147351403929796608182862360884493684335369478368770819127290582786157697798388245982826545951852875217150701541970900785626379830835719158822235848
e = 65537

p,_ = gmpy2.iroot(n, 2)
while n % p:
  p = gmpy2.next_prime(p)
print(p)
q = n // p
assert n == p * q
phin = (p - 1) * (q - 1)
d = gmpy2.invert(e, phin)
m = pow(c, d, n)
print(unhexlify(hex(m)[2:])) # flag{25adeb5c641848b8a1a6871bd0b162ae}
```
